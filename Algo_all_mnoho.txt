➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ python3 .
Lesson ID: LC_0002; Status: [200], uuAppErrorMap: {}
QC_0001
<uu5string/>Ze kterých hledisek se dá nahlížet na složitost algoritmu?
	 prostorová složitost
	 časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0002
Kterými způsoby můžeme spočítat složitost algoritmu?
	 počet elementárních operací
	 počet elementárních operací nad daty
	 počet porovnání
------------------------------------------------------------------------------------------------------------------------------
QC_0003
Na složitost algoritmu lze nahlížet z různých hledisek, z následujícího sestavte správné tvrzení.
------------------------------------------------------------------------------------------------------------------------------
QC_0004
 K vyjádření časové složitosti používáme $1, která je závislá na velikosti vstupních dat.
	 funkci
------------------------------------------------------------------------------------------------------------------------------
QC_0005
<uu5string/>$1 udává, jak je daný algoritmus rychlý, neboli kolik provede elementárních operací vzhledem k množině vstupních dat.
	 <uu5string/>Časová složitost
------------------------------------------------------------------------------------------------------------------------------
QC_0006
<uu5string/>Rychlost algoritmu závisí <UU5.Bricks.U>jen</UU5.Bricks.U> na objemu vstupních dat.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574405787252
Co z následujícího se dá považovat za algoritmus?
	 <uu5string/>návod na Rubikovu kostku
	 recept na palačinky
	 návod k obsluze tiskárny
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0003; Status: [200], uuAppErrorMap: {}
QC_1574406217633
Jak se zapisuje asymptotická složitost algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(f(N))"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574407202769
Uspořádejte asymptotické složitosti vzestupně.
	 <uu5string/><UU5.Math.Expression expression="O(1)"/>
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
	 <uu5string/><UU5.Math.Expression expression="O(n!)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574409874074
$1 je v podstatě rozdělení algoritmů do tříd složitostí.
	 Asymptotická složitost
------------------------------------------------------------------------------------------------------------------------------
QC_1574410666567
Při konstantní složitosti $1 na množství vstupních dat a čas potřebný pro zpracování bude $2.
	 nezáleží 
	 stejný
------------------------------------------------------------------------------------------------------------------------------
QC_1574424911511
Uspořádejte asymptotické složitosti vzestupně.
	 logaritmická
	 kvadratická
	 kubická
	 exponenciální
------------------------------------------------------------------------------------------------------------------------------
QC_1579508404251
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro svou nízkou hodnotu <UU5.Math.Expression expression="n"/> <UU5.Math.Expression expression="(n < 5)"/>?
	 B
------------------------------------------------------------------------------------------------------------------------------
QC_1579508957912
<uu5string/>Mějme algoritmus A s délkou výpočtu <UU5.Math.Expression expression="n + 1000"/> a algorimus B s délkou výpočtu
<UU5.Math.Expression expression="4^n"/>, kde <UU5.Math.Expression expression="n"/> je počet vstupních dat.
Který algoritmus z hlediska časové složitosti je vhodnější pro hodnoty, kdy <UU5.Math.Expression expression="n"/> je z množiny celých kladných čísel?
	 A
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0004; Status: [200], uuAppErrorMap: {}
QC_1574664462845
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 100"/>. 
Pokud číslo <UU5.Math.Expression expression="206"/> můžeme zapsat jako <UU5.Math.Expression expression="BBAAA"/> 
nebo <UU5.Math.Expression expression="AAABB"/>, případně <UU5.Math.Expression expression="AABBA"/> atd. 
O kterou číselnou soustavu se potom jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574664660374
<uu5string/><UU5.Bricks.P>
Mějme symboly <UU5.Math.Expression expression="A"/> a <UU5.Math.Expression expression="B"/>, 
kde <UU5.Math.Expression expression="A = 2"/> a <UU5.Math.Expression expression="B = 20"/>. 
Pokud číslo <UU5.Math.Expression expression="42"/> můžeme zapsat jako <UU5.Math.Expression expression="BBA"/>, <UU5.Math.Expression expression="BAB"/> nebo <UU5.Math.Expression expression="ABB"/>.
O kterou číselnou soustavu se jedná?
</UU5.Bricks.P>
	 nepoziční číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574665747016
<uu5string/>Pro reprezentaci dat využívají digitální zařízení $1.
	 binární číselnou soustavu
------------------------------------------------------------------------------------------------------------------------------
QC_1574666027928
<uu5string/>Pro zápis čísla se v dekadické soustavě používají číslice <UU5.Math.Expression expression=" \displaystyle 1 - 10"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1574674741596
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="0001 1001"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="25"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1574675110526
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="224"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="1110 0000"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1575961801633
<uu5string/>Převeďte desítkové číslo <UU5.Math.Expression expression="56"/> do binární soustavy.
	 <uu5string/><UU5.Math.Expression expression="‭00111000‬"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1605878964548
<uu5string/><UU5.Bricks.P>
Mějme číslo <UU5.Math.Expression expression="256"/>.
Do které číselné soustavy patří?
</UU5.Bricks.P>
	 <uu5string/>poziční číselná soustava
------------------------------------------------------------------------------------------------------------------------------
QC_1619428762096
<uu5string/>Převeďte binární číslo <UU5.Math.Expression expression="\displaystyle 0010 0010"/> do desítkové soustavy.
	 <uu5string/><UU5.Math.Expression expression="34"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0005; Status: [200], uuAppErrorMap: {}
QC_1575372926263
<uu5string/>Pokud <UU5.Math.Expression expression="x = 2"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="!(x==y)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575373154963
Přiřaď k logické operaci odpovídající symbol.
------------------------------------------------------------------------------------------------------------------------------
QC_1575373569943
$1 vrací 1 v případě, že jsou oba činitelé 1, v ostatních případech 0. 
	 Logický součin
------------------------------------------------------------------------------------------------------------------------------
QC_1575373820261
$1 vrací 1 v případě, že alespoň jeden sčítanec je 1, v ostatních případech 0. 
	 Logický součet
------------------------------------------------------------------------------------------------------------------------------
QC_1575377949861
<uu5string/>Pokud <UU5.Math.Expression expression="x = 5"/> a <UU5.Math.Expression expression="y = 2"/>. Poté nám operace <UU5.Math.Expression expression="(x>y)"/> && <UU5.Math.Expression expression="(y>5)"/> vrátí $1.
	 FALSE
------------------------------------------------------------------------------------------------------------------------------
QC_1575378885846
<uu5string/>Pokud <UU5.Math.Expression expression="x = 1"/> a <UU5.Math.Expression expression="y = 6"/>. Poté nám operace <UU5.Math.Expression expression="(x > 2)"/> || <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575379880739
<uu5string/>Pokud <UU5.Math.Expression expression="x = 4"/> a <UU5.Math.Expression expression="y = 3"/>. Poté nám operace <UU5.Math.Expression expression="(x > 3)"/> ^ <UU5.Math.Expression expression="(y == 6)"/> vrátí $1.
	 TRUE
------------------------------------------------------------------------------------------------------------------------------
QC_1575381878625
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> AND <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000100
------------------------------------------------------------------------------------------------------------------------------
QC_1575382053135
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> OR <UU5.Math.Expression expression="y"/> vrátí $1.
	 00000101
------------------------------------------------------------------------------------------------------------------------------
QC_1575382305830
<uu5string/>Pokud <UU5.Math.Expression expression="x = 0000 0100"/> a <UU5.Math.Expression expression="y = 0000 0101"/>. Poté nám operace <UU5.Math.Expression expression="x"/> XOR <UU5.Math.Expression expression="y"/> vrátí $1.
	 1
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0006; Status: [200], uuAppErrorMap: {}
QC_1575618319429
<uu5string/>Čemu odpovídá posuv doleva/doprava o <UU5.Math.Expression expression="n"/> pozic?
------------------------------------------------------------------------------------------------------------------------------
QC_1575621365500
<uu5string/>U aritmetického posuvu se hodnota nejvyššího (nejvýznamnějšího) bitu $1, i když v případě logického posuvu na obě krajní pozice se vždy nasouvají hodnoty $2 i v případě nejvyšších bitů.
	 zachovává
	 0
------------------------------------------------------------------------------------------------------------------------------
QC_1575621943411
Bit, který je při $1 vysouván z hodnoty ven, je při $2 opět vkládán na opačném konci.
	 posuvu
	 rotaci 
------------------------------------------------------------------------------------------------------------------------------
QC_1575624479037
Jak bude vypadat číslo 10010111 po aritmetickém posunu o jednu pozici doprava?
	 11001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575624679199
Jak bude vypadat číslo 10010111 po logickém posunu o jednu pozici doprava?
	 01001011
------------------------------------------------------------------------------------------------------------------------------
QC_1575625701014
Jak bude vypadat číslo 00010111 po rotaci doleva?
	 00101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575625916015
Jak bude vypadat číslo 00010111 po rotaci doprava?
	 10001011
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0007; Status: [200], uuAppErrorMap: {}
QC_1575635049942
Turingův stroj se využívá pro modelování $1.
	 algoritmů v teorii vyčíslitelnosti
------------------------------------------------------------------------------------------------------------------------------
QC_1575635302336
Ze kterých častí se skládá Turingův stroj?
	 procesorové jednotky
	 programu 
	 nekonečné pásky
------------------------------------------------------------------------------------------------------------------------------
QC_1575636076442
<uu5string/>Který z následujících programovacích jazyků považujeme za ekvivalentní Turingovu stroji (turingovsky úplný)?
	 JavaScript
	 Java
	 Ruby
------------------------------------------------------------------------------------------------------------------------------
QC_1575636832929
<uu5string/>Co všechno by měl splňovat algoritmus podle Churchovy-Turingovy teze?
	 nevyžadovat lidskou inteligenci pro spuštění
	 být proveditelný i člověkem s tužkou a papírem
	 vždy vrátit výsledek po konečném počtu kroků
	 skládat se z konečného počtu instrukcí
------------------------------------------------------------------------------------------------------------------------------
QC_1575640961781
Co všechno platí pro konečný automat?
	 pamatuje si pouze aktuální stav
	 mezi stavy přechází na základě symbolů, které čte ze vstupu
	 může být v jednom z několika stavů
------------------------------------------------------------------------------------------------------------------------------
QC_1575643926729
K přechodu mezi stavy konečný automat využívá tzv. $1. 
	 přechodovou funkci (tabulku)
------------------------------------------------------------------------------------------------------------------------------
QC_1575875559661
Co platí pro deterministický a nedeterministický automat?
------------------------------------------------------------------------------------------------------------------------------
QC_1575875983256
<uu5string/>Vícepáskový Turingův stroj lze plnohodnotně nahradit jednopáskovým Turingovým strojem.
	 True
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0008; Status: [200], uuAppErrorMap: {}
QC_1575878810960
Co je to složitost algoritmu a složitost problému?
------------------------------------------------------------------------------------------------------------------------------
QC_1575880267366
Pro každý problém existuje polynomiální algoritmus, který ho řeší.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575890429531
Co patří mezi typické NP-úplné úlohy?
	 problém dvou zlodějů
	 zavazadlový problém
	 problém obchodního cestujícího
------------------------------------------------------------------------------------------------------------------------------
QC_1575891934687
Přiřaďte příslušné třídě složitosti její název.
------------------------------------------------------------------------------------------------------------------------------
QC_1579505238605
<uu5string/>Pokud je časová složitost funkce <UU5.Math.Expression expression="f(N)"/> polynomem, hovoříme o $1 a problémy,
které takový algoritmus řeší, řadíme do třídy $2. 
	 polynomiálně omezených algoritmech
	 P (polynomiální)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0009; Status: [200], uuAppErrorMap: {}
QC_1575896143150
Co z následujícího považujeme za abecedu jazyku v informatice?
	 {a, b}
	 {a, b, c}
	 {1, 0}
	 {a, 1, b, 0}
------------------------------------------------------------------------------------------------------------------------------
QC_1575897063219
Pokud abeceda je {0,1}, jak potom může vypadat řetězec?
	 0101110
------------------------------------------------------------------------------------------------------------------------------
QC_1575897240875
Pokud abeceda je {b,a} jak potom může vypadat řetězec?
	 bababbba
------------------------------------------------------------------------------------------------------------------------------
QC_1575897572687
Přiřaď každému typu odpovídající gramatiku.
------------------------------------------------------------------------------------------------------------------------------
QC_1575898310800
<uu5string/><UU5.Bricks.U>Ne všechny</UU5.Bricks.U> řetězce jsou generované nějakou formální gramatikou.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575899248324
Všechny řetězce $1 nějakým automatem, například Turingovým strojem nebo konečným automatem.
	 jsou akceptované 
------------------------------------------------------------------------------------------------------------------------------
QC_1576225280566
Které typy gramatik zahrnují kontextové typy gramatik?
	 bezkontextové
	 regulární
------------------------------------------------------------------------------------------------------------------------------
QC_1576225450854
<uu5string/>Jazyky používající gramatiku $1 jsou rozpoznatelné lineárně ohraničeným Turingovým strojem.
	 kontextovou
------------------------------------------------------------------------------------------------------------------------------
QC_1576225678728
Jazyky používající $1 gramatiku jsou rozpoznatelné nedeterministickým zásobníkovým automatem.
	 bezkontextovou
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0010; Status: [200], uuAppErrorMap: {}
QC_1575968325517
<uu5string/>Přiřaď význam přímé a nepřímé rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575968564834
Lze každou rekurzi nahradit iterací a naopak?
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1575969173026
Použití rekurze místo iterace vždy vede k optimálnějšímu a rychlejšímu řešení.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1575969914693
<uu5string/>Přiřaď význam lineární a stromové rekurze.
------------------------------------------------------------------------------------------------------------------------------
QC_1575971362274
<uu5string/>Když se dva a více programů volají vzájemně, o který typ rekurze se jedná?

	 o nepřímou rekurzi
------------------------------------------------------------------------------------------------------------------------------
QC_1575978672324
<uu5string/>Pokud algoritmus neobsahuje $1, jedná se o $2 algoritmus.
	 ukončovací podmínku (tzv. zarážku)
	 nekonečný
------------------------------------------------------------------------------------------------------------------------------
QC_1575982614445
$1 představuje opakované vnořené volání stejného podprogramu (funkce).
	 Rekurze
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0011; Status: [200], uuAppErrorMap: {}
QC_1575979646133
U které varianty se faktoriál čísla řeší pomocí rekurze?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function factorial(n) {    if (n < 0) return -1    if (n == 0 || n == 1) return 1    return n * factorial(n - 1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980196206
Které řešení Fibonacciho posloupnosti je efektivní a optimální?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function fibonacci(n) {	  if (n == 0) return 0  	if (n == 1) return 1  	  	let result = 0  	let lastNum = 0  	let num = 1	  for (i = 1; i < n; i++) { 	  	result = lastNum + num  	lastNum = num	  	num = result  	}  		  return result}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575980503123
U kterého příkladu se jedná o nepřímou rekurzi?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(n) {    if (n < 1) return 1    else return 1 + functionB(n)}function functionB(n) {    return functionA(n-1)}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1575986812179
<uu5string/>Jak lze vypočítat <UU5.Math.Expression expression="x^n"/> pro <UU5.Math.Expression expression="n > 0"/>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function functionA(x, n) {    if (n==0) return 1    else return (x * functionA(x, n-1))}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576054800143
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat funkce v JavaScript <UU5.Bricks.U>s použitím rekurze</UU5.Bricks.U>, která ověří, zda se jedná o tzv. palindrom?
</UU5.Bricks.P>
<UU5.Bricks.Em>
  Palindrom je text, který je stejný při čtení zepředu i zezadu (například slovo kajak).
</UU5.Bricks.Em>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function palindrome(str) {    let cleanStr = clean(str);    let strLength = cleanStr.length;        if (strLength < 2) {        return true;    }    if (cleanStr[0] == cleanStr[strLength - 1]) {        return palindrome(cleanStr.slice(1, strLength - 1));    }    return false;};</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576055825672
Jak bude vypadat funkce v JavaScript s použitím rekurze pro tisk řetězce pozpátku?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  function reverseString(str) {  if (str === "")    return "";  else    return reverseString(str.substr(1)) + str.charAt(0);}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1582532661331
<uu5string/>V kterém pořadí se vykonávají základní kroky rekurzivní funkce?
	 Kontrola (zda vstupní parametry odpovídají stanoveným podmínkám)
	 Inicializace (tj. nastavení hodnot, s nimiž se výpočet zahájí)
	 Provádění samotné rekurze (zavolání funkcí, které řeší daný podproblém, sestavení výsledku)
	 Vrácení výsledku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0012; Status: [200], uuAppErrorMap: {}
QC_1576064761010
Ze kterých základních častí se skládá spojový seznam?
	 uzel
	 začátek seznamu (head) 
	 patička seznamu (tail)
	 iterátor
------------------------------------------------------------------------------------------------------------------------------
QC_1576064895886
Spojový seznam slouží k ukládání dat předem $1 délky.
	 neznámé 
------------------------------------------------------------------------------------------------------------------------------
QC_1576065541570
<uu5string/>Přiřaď význam jednotlivých prvků spojového seznamu.
------------------------------------------------------------------------------------------------------------------------------
QC_1576065984012
$1 seznam lze procházet směrem „doleva“ i „doprava“.
	 Obousměrný
------------------------------------------------------------------------------------------------------------------------------
QC_1576066414735
<uu5string/>Pokud budeme chtít smazat prvek seznamu, který je potřeba vyhledat, tak složitost této operace bude $1.
	 <uu5string/><UU5.Math.Expression expression="O(n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1576067322730
Co z následujícího platí pro každý typ seznamu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576067795909
Na kterém obrázku je zobrazen kruhový seznam?
	 {'image': '827912f28988379463ee38cb22fe49e4de13d4730ab618eae1d5708c1151d7d2', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576069073283
Které všechny operace můžeme provádět nad datovou strukturou seznam?
	 Přidání prvku
	 Vyhledání prvku
	 Náhodný přístup k prvku
	 Mazání prvku
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0013; Status: [200], uuAppErrorMap: {}
QC_1576076972153
Pole je primárně určeno pro $1 skupinu prvků.
	 konečnou 
------------------------------------------------------------------------------------------------------------------------------
QC_1576077252907
Pomocí čeho přistupujeme k jednotlivým prvkům v poli?
	 indexu
------------------------------------------------------------------------------------------------------------------------------
QC_1576078213857
<uu5string/>Pokud přidáváme prvek na začátek pole, tak asymptotická složitost této operace bude <UU5.Math.Expression expression="O(1)"/>.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576078742355
Co všechno z následujícího můžeme považovat za index pole?
	 8
	 960
------------------------------------------------------------------------------------------------------------------------------
QC_1576143241674
Přiřaď každé operaci její asymptotickou složitost.
------------------------------------------------------------------------------------------------------------------------------
QC_1576147509600
<uu5string/>U kterých příkladu se jedná o <UU5.Bricks.U>dvourozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [[1, 0, 1, 1, 0], [1, 0], [0, 1]];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [[a, b], [c, d], [e, f]];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576148306955
<uu5string/>Prvky v poli se indexují <UU5.Bricks.U>vždy</UU5.Bricks.U> od 0.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576148560055
<uu5string/>U kterých příkladů se jedná o <UU5.Bricks.U>jednorozměrné</UU5.Bricks.U> pole?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let bin = [1, 0, 1, 1, 1, 0];</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">let abc = [a, b, c, d, e, f];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0014; Status: [200], uuAppErrorMap: {}
QC_1576239199861
Přiřaď každému pojmu související zkratku a obrázek.
------------------------------------------------------------------------------------------------------------------------------
QC_1576240365259
Co znamená zkratka LIFO?
	 Poslední vložený prvek do zásobníku bude prvním prvkem, který ze zásobníku vyjmeme.
------------------------------------------------------------------------------------------------------------------------------
QC_1576241015958
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>push</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 2, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.push(4);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 2, 3, 4, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576241412623
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>pop</UU5.Bricks.Code> nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, null, 3, 4]; //číslo 4 - ukazatel zásobníku
  stack.pop();
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, null, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576242261555
<uu5string/>Pro kterou metodu je platný výraz <UU5.Bricks.Em>"Kdo dřív přijde, ten dřív mele"</UU5.Bricks.Em>?
	 FIFO
------------------------------------------------------------------------------------------------------------------------------
QC_1576243502380
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>enqueue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.unshift(0); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 0, 1, 2, 3, 3, 4];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576244053075
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení operace <UU5.Bricks.Code>dequeue</UU5.Bricks.Code> nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [0, 1, 2, 3, 3];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576245359722
<uu5string/><UU5.Bricks.P>
  Jaký bude výsledek po provedení následujících operací nad frontou?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let queue = [0, 1, 2, 3, 3, 4]; //číslo 4 - začátek fronty
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.pop(); // dequeue
  queue.unshift(2); // enqueue
  queue.unshift(-1); // enqueue
  queue.unshift(1); // enqueue
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let queue = [1, -1, 2, 0, 1, 2]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1576247288733
<uu5string/><UU5.Bricks.P>
 Jaký bude výsledek po provedení následujících operaci nad zásobníkem?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
  let stack = [1, 2, 3, 3, 4, 5]; //číslo 5 - ukazatel zásobníku
  stack.pop();
  stack.pop();
  stack.push(stack.pop());
  stack.push(5);
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">  let stack = [1, 2, 3, 3, 5];</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0015; Status: [200], uuAppErrorMap: {}
QC_1576501596939
Množina umožňuje duplicity stejně jako spojový seznam a pole.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576502224780
Množina je modelovou datovou strukturou, kterou lze realizovat pomocí $1 nebo $2.
	 pole 
	 spojového seznamu
------------------------------------------------------------------------------------------------------------------------------
QC_1576502619846
Co z následujícího platí pro množinu?
	 Umožňuje ukládat libovolné prvky, ale bez určení konkrétního pořadí.
	 Lze realizovat pomocí pole nebo spojového seznamu.
	 Neumožňuje duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1576503145631
Co umožňují následující typy množin?
------------------------------------------------------------------------------------------------------------------------------
QC_1576504345256
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.subSet = function(otherSet) 
{ 
    if(this.size > otherSet.size) 
        return false; 
    else
    { 
        for(let elem of this) 
        { 
            if(!otherSet.has(elem)) 
                return false; 
        } 
        return true; 
    } 
} 

let setA = new Set([1, 4, 6]); 
let setB = new Set([5, 6, 1, 2, 3, 4]); 

console.log(setA.subSet(setB))
</UU5.CodeKit.CodeViewer>

</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576504796147
<uu5string/><UU5.Bricks.P>
 Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.union = function(otherSet) 
{ 
    let unionSet = new Set(); 
  
    for (let elem of this) 
    { 
        unionSet.add(elem); 
    } 
  
    for(let elem of otherSet) 
        unionSet.add(elem); 
  
    return unionSet; 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([5, 6, 7, 8]);   

let unionSet = set1.union(set2); 
  
console.log(unionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505182929
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.intersection = function(otherSet) 
{ 
    let intersectionSet = new Set(); 
  
    for(let elem of otherSet) 
    { 
        if(this.has(elem)) 
            intersectionSet.add(elem); 
    } 
  
return intersectionSet;                 
} 

let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let intersectionSet = set1.intersection(set2); 
  
console.log(intersectionSet.values()); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576505519622
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
Set.prototype.difference = function(otherSet) 
{ 
     let differenceSet = new Set(); 
  
    for(let elem of this) 
    { 
        if(!otherSet.has(elem)) 
            differenceSet.add(elem); 
    } 
  
    return differenceSet; 
} 
  
let set1 = new Set([1, 2, 3, 4, 5]); 
let set2 = new Set([4, 5, 6, 7, 8]);   
  
let differenceSet = set1.difference(set2); 
  
console.log(differenceSet); 
</UU5.CodeKit.CodeViewer>
</UU5.CodeKit.CodeViewer>.CodeKit.CodeViewer codeStyle="javascript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576506269199
<uu5string/><UU5.Bricks.P>
  Co bude vypsáno do konzole po provedení následující operace?
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
let set1 = new Set(); 
  
set1.add(1); 
set1.add(2); 
  
set1.add(3).add(4).add(5); 

set1.delete(1).delete(2);
  
console.log(set1); 
</UU5.CodeKit.CodeViewer>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">[3, 4, 5]</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0016; Status: [200], uuAppErrorMap: {}
QC_1576567310718
Kruhový buffer je implementací $1 nad $2, která se používá především jako vyrovnávací paměť datových toků.
	 fronty (FIFO)
	 polem 
------------------------------------------------------------------------------------------------------------------------------
QC_1576567928171
Z čeho se skládá kruhový buffer?
	 dvou ukazatelů
	 pole fixní délky
------------------------------------------------------------------------------------------------------------------------------
QC_1576568169474
Jaká je funkce jednotlivých ukazatelů v kruhovém bufferu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576568960185
Asymptotická složitost výběru a čtení prvku na prvním indexu je  $1 , složitost operace přidání prvku na konec fronty je  $2 .
	 <uu5string/>O (1)
	 <uu5string/>O (1)
------------------------------------------------------------------------------------------------------------------------------
QC_1576569325717
Co se stane, když do bufferu bude přidán nový prvek?
	 <uu5string/>Druhý ukazatel (<UU5.Bricks.Code>EndPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
QC_1576569834014
<uu5string/>Co se stane v případě odstranění prvního prvku bufferu?
	 <uu5string/>První ukazatel (<UU5.Bricks.Code>StartPointer</UU5.Bricks.Code>) inkrementuje.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0017; Status: [200], uuAppErrorMap: {}
QC_1576573295229
Pomocí čeho přistupujeme k jednotlivým prvkům v asociativním poli?
	 Pomocí klíče.
------------------------------------------------------------------------------------------------------------------------------
QC_1576574457843
<uu5string/>Kde je zapsáno asociativní pole správně?
</UU5.CodeKit.CodeViewer>wo": 2, "three": 3 }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> "two", 3: "three" }; deStyle="javascript">
</UU5.CodeKit.CodeViewer> 2: "two", 3: "three" }; tyle="javascript">
</UU5.CodeKit.CodeViewer>, "two": "two", "three": "three" }; cript">
------------------------------------------------------------------------------------------------------------------------------
QC_1576574718563
Co všechno muže být klíčem v asociativním poli?
	 datum
	 řetězec (text)
	 celé číslo
	 binární číslo
------------------------------------------------------------------------------------------------------------------------------
QC_1576578652467
Asymptotická složitost přidávání prvku do asociativního pole je vždy $1.
	 O (1)
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0018; Status: [200], uuAppErrorMap: {}
QC_1576655624272
Co platí pro následující typy stromu?
------------------------------------------------------------------------------------------------------------------------------
QC_1576656161442
Přiřaď každému typu uzlu jeho význam.
------------------------------------------------------------------------------------------------------------------------------
QC_1576656304643
Strom, který obsahuje jeden prvek, je také stromem.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1576657118502
Na kterém obrázku je označen kořen stromu (root)?
	 {'image': '04f9ed2327dc81aa8e34d9a13aeff15edc1846e781e3e6cde4b8753f9cbd3f6e', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657261682
Na kterém obrázku je označen vnitřní uzel stromu (inner node)?
	 {'image': '9726efa4c45cf6ec8311358f0ca16ca6a5cc18c0c02c25a1d04a7b93e49917e6', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576657351462
Na kterém obrázku je označen koncový uzel stromu (leaf, leaf node)?
	 {'image': 'b9327c277b6b550b29b2589d8fb5807fc1189d9d4c7b63f5124586f9ebabceff', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1576658788002
Co všechno může obsahovat uzel stromu?
	 vlastní strom
	 reprezentovat strukturu oddělených dat
	 podmínku
	 hodnotu
------------------------------------------------------------------------------------------------------------------------------
QC_1576670718562
délka cesty = $1 - $2
	 počet uzlů v cestě
	 1
------------------------------------------------------------------------------------------------------------------------------
QC_1576670912810
Čím je dána šířka stromu?
	 počtem uzlů na stejné úrovni
------------------------------------------------------------------------------------------------------------------------------
QC_1576671633322
<uu5string/>Jedná se o vyvážený strom?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=f606e6bda2b3eae644ca5bd1c79329eae6604cffa88296151a0f66ec0519d037"
	style="maxHeight: 200px"
/>
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1576674722570
N-arita nám říká, kolik $1 může mít daný uzel maximálně.
	 potomků 
------------------------------------------------------------------------------------------------------------------------------
QC_1578918080484
<uu5string/>Které základní možností průchodu uspořádaným stromem existují?
------------------------------------------------------------------------------------------------------------------------------
QC_1578918378399
<uu5string/>Jak fungují následující způsoby procházení stromu?
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0019; Status: [200], uuAppErrorMap: {}
QC_1578918934324
Všechny podstromy haldy jsou také haldy.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578919517705
<uu5string/>Pokud indexujeme v haldě od hodnoty 0, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i + 1
	 2 ⋅ i + 2
------------------------------------------------------------------------------------------------------------------------------
QC_1578919769722
<uu5string/>Pokud indexujeme v haldě od hodnoty 1, pak pro potomky bude platit  $1 a  $2 .
	 2 ⋅ i 
	 2 ⋅ i + 1
------------------------------------------------------------------------------------------------------------------------------
QC_1578922463095
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 7, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 2 + 1 = 5
------------------------------------------------------------------------------------------------------------------------------
QC_1578922651832
<uu5string/><UU5.Bricks.P>
  Na kterém indexu se nachází hodnota 9, pokud indexujeme od 0 shora dolů a zleva doprava.
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=330f6c2e896bf3b590c8a873e348a6f7fc9c9f92300e58c04d6a9b39d4540af0"
	style="maxHeight: 200px"
/>
	 2 · 1 + 2 = 4
------------------------------------------------------------------------------------------------------------------------------
QC_1578923420516
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po smazaní kořené (root)?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=d7a5fb84238417160f4b552df5cad5913f798199d25e817c3a65c821e8b209b4"
	style="maxHeight: 200px"
/>
	 {'image': '9d55f10cf68b47e836e14290e08456ed9de7a658c3d24fccc682263a1972d203', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578923937902
<uu5string/><UU5.Bricks.P>
 Jak bude vypadat halda po vložení hodnoty 6?
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=9d0b247efcdb7034d683471be65992b9a1eb5f33c1d43c78cbc185276016d7e1"
	style="maxHeight: 200px"
/>
	 {'image': '18d64a4f8d9164238616a0e5dcf39a7b52b78d1bcde9510fac92dd335d34383c', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1578985896474
Jak bude vypadat postup přidávaní nového prvku v max heap?
	 Vytvoříme uzel na konci haldy.
	 Přidáme do uzlu hodnotu.
	 Pokud hodnota je menší než rodič, je nutné ukončit běh.
	 Pokud hodnota je větší než rodič, je nutné prohodit uzly.
	 Je nutné opakovat krok 3 a 4, dokud se nesplní základní vlastnost haldy.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0020; Status: [200], uuAppErrorMap: {}
QC_1578990125561
Kterou část záznamu používáme pro porovnávání prvku?
	 klíč
------------------------------------------------------------------------------------------------------------------------------
QC_1578990489590
Pojem $1 znamená zajistit uspořádání záznamů (například pole, spojový seznam, soubor) do požadovaného pořadí.
	 řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1578990759173
Jak funguji následující typy algoritmu?
------------------------------------------------------------------------------------------------------------------------------
QC_1578990999312
Z libovolného nestabilního řadicího algoritmu lze učinit algoritmus stabilní.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1578992068439
<uu5string/><UU5.Bricks.P>
 O který typ algoritmu se jedná, pokud:
</UU5.Bricks.P>
<UU5.CodeKit.CodeViewer codeStyle="javascript">
INPUT: (4, 5), (3, 2), (4, 3), (5, 4), (6, 4) // (klíč, hodnota)
OUTPUT1: (3, 2),  (4, 5),  (4, 3),  (5, 4),  (6, 4)
OUTPUT2: (3, 2),  (4, 3),  (4, 5),  (5, 4),  (6, 4)
</UU5.CodeKit.CodeViewer>
	 nestabilní
------------------------------------------------------------------------------------------------------------------------------
QC_1578992712491
<uu5string/><UU5.Bricks.P>
 U kterého příkladu se jedná o stabilní algoritmus?
</UU5.Bricks.P>
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Wells, Nada), (Beattie, Blanka), (Beattie, Samiya) //(klíč, hodnota)OUTPUT1: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)OUTPUT2: (Beattie, Blanka), (Beattie, Samiya), (Wells, Nada)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1578995540130
U kterého příkladu se jedná o nestabilní algoritmus?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">INPUT: (Connelly, Jaheim, 18), (Brewer, Anabel, 21), (Brewer, Ayrton, 21) //(klíč, hodnota, klíč)OUTPUT1: (Brewer, Anabel, 21), (Brewer, Ayrton, 21), (Connelly, Jaheim, 18)OUTPUT2: (Brewer, Ayrton, 21), (Brewer, Anabel, 21), (Connelly, Jaheim, 18)</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0021; Status: [200], uuAppErrorMap: {}
QC_1579001019228
Který typ dle umístění vstupních záznamů použijeme v případě, kdy je nedostatek paměti a my nejsme schopni do této paměti uložit všechny záznamy?
	 vnější řazení
------------------------------------------------------------------------------------------------------------------------------
QC_1579001808247
Co znamená vnitřní a vnější řazení?
------------------------------------------------------------------------------------------------------------------------------
QC_1579003772828
<uu5string/>$1 pracuje tak, že vstupní záznamy rozděluje na části se záznamy odpovídající určitému kritériu, přičemž rozdělování končí u úseků se dvěma nebo jedním prvkem.
	 Rozdělovací metoda
------------------------------------------------------------------------------------------------------------------------------
QC_1579004392951
Na které animaci je zobrazeno řazení slučovací metodu?
	 {'image': 'f17bd24dd2230632d5adafe190826520272492b76f37a0d5799cd7cdc1076bb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579005529055
<uu5string/>Za $1 se považuje algoritmus, který zpracuje rychleji seřazenou nebo částečně seřazenou posloupnost,
když $2 zpracovávaní seřazené nebo částečně seřazené posloupnosti trvá déle.
	 přirozený algoritmus
	 nepřirozenému algoritmu
------------------------------------------------------------------------------------------------------------------------------
QC_1579005811822
<uu5string/>Podle kterých kriterií se dají dělit algoritmy řazení?
	 Dle sekvenčnosti.
	 Dle stability algoritmu.
	 Dle paměťové náročnosti.
	 Dle časové složitosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579005958116
<uu5string/>Říkáme, že řazení je $1, pokud <UU5.Bricks.U>nedojde</UU5.Bricks.U> v jeho průběhu k prohození prvků se stejnou hodnotou. 
	 stabilní
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0022; Status: [200], uuAppErrorMap: {}
QC_1579070070216
V čem spočívá základní myšlenka algoritmu selection sort?
	  V nalezení minima/maxima, které se přesune na začátek/konec pole.
------------------------------------------------------------------------------------------------------------------------------
QC_1579070294269
<uu5string/>Jaké platí vlastnosti pro algoritmus selection sort?
	 <uu5string/>časová složitost <UU5.Math.Expression expression="O(n^2)"/>
	 je pomalý
	 není přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579070589143
Jak vypadá průběh algoritmu selection sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou část.
	 Najít prvek s nejmenší hodnotou v neseřazené části posloupnosti.
	 Zaměnit nalezený prvek s prvkem na první pozici neseřazené části.
	 První prvek neseřazené části zahrnout do seřazené části a zároveň neseřazenou část zmenšit o 1 prvek zleva.
	 Opakovat kroky 2 až 5 pro zbylou neseřazenou část.
------------------------------------------------------------------------------------------------------------------------------
QC_1579071135898
Selection sort je vhodný zejména pro uspořádání $1 množství dat.
	 malých
------------------------------------------------------------------------------------------------------------------------------
QC_1579071675049
<uu5string/>Algoritmus selection sort $1, to znamená že může změnit pořadí u prvků se shodným klíčem a $2 mezi přirozené řadicí algoritmy 
(částečně seřazený seznam se bude zpracovávat stejně dlouho jako neseřazený).
	 není stabilní
	 nepatří
------------------------------------------------------------------------------------------------------------------------------
QC_1579072758850
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel [5, 3, 6, 2, 1, 4]
	 [1, 3, 6, 2, 5, 4]
	 [1, 2, 6, 3, 5, 4]
	 [1, 2, 3, 6, 5, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579073757549
Který z pseudokódů je pseudokódem algoritmu selection sort? 
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function selectionSort(array, opt="asc") {  compare = (opt === "asc") ? compareAsc : compareDesc;  for (let i = 0; i < array.length - 1; i++) {    let searchIndex = i;    for (let j = i + 1; j < array.length; j++) {      if (compare(array[j],array[searchIndex])) {         searchIndex = j;      }    }    let item = array[i];    array[i] = array[searchIndex];    array[searchIndex] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579074546484
<uu5string/>Jak bude vypadat průběh řazení algoritmem selection sort pro pole čísel
 [51, 43, 26, 32, 15, 62]
	 [15, 43, 26, 32, 51, 62]
	 [15, 26, 43, 32, 51, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0023; Status: [200], uuAppErrorMap: {}
QC_1579075820649
<uu5string/>Jaké platí vlastnosti pro algoritmus insertion sort?
	 <uu5string/>časová složitost  <UU5.Math.Expression expression="O (n^2)"/>
	 je stabilní
	 je přirozený
------------------------------------------------------------------------------------------------------------------------------
QC_1579076610944
Co platí pro následující řadicí algoritmy?
------------------------------------------------------------------------------------------------------------------------------
QC_1579076806141
V čem spočívá základní myšlenka algoritmu insertion sort?
	 Každý nezařazený prvek algoritmus zařadí na správné místo do již seřazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579077488807
Jak vypadá průběh algoritmu insertion sort?
	 Rozdělit posloupnost na seřazenou a neseřazenou tak, že seřazená obsahuje první prvek posloupnosti.
	 Z neseřazené části vybrat první prvek a zařadit jej na správné místo v seřazené posloupnosti.
	 Prvky v seřazené posloupnosti posunout o jednu pozici doprava.
	 Seřazenou část zvětšit o jeden prvek. Naopak neseřazenou část o jeden prvek zleva zmenšit.
	 Kroky 2–5 opakovat až do úplného seřazení neseřazené části.
------------------------------------------------------------------------------------------------------------------------------
QC_1579078211427
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [5, 3, 1, 2, 6, 4]
	 [3, 5, 1, 2, 6, 4]
	 [1, 3, 5, 2, 6, 4]
	 [1, 2, 3, 5, 6, 4]
	 [1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579078371493
Který z kódů je kódem algoritmu insertion sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function insertionSortAscending(array) {  for (let i = 0; i < array.length; i++) {    let j = i - 1;    let item = array[i];    while (j >= 0 && item < array[j]) {      array[j + 1] = array[j];      j--;    }    array[j + 1] = item;  }}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579078501029
<uu5string/>Jak bude vypadat průběh řazení algoritmem insertion sort pro pole čísel [51, 43, 26, 32, 15, 62]
	 [43, 51, 26, 32, 15, 62]
	 [26, 43, 51, 32, 15, 62]
	 [26, 32, 43, 51, 15, 62]
	 [15, 26, 32, 43, 51, 62]
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0024; Status: [200], uuAppErrorMap: {}
QC_1579083550045
<uu5string/>Jaké platí vlastnosti pro algoritmus bubble sort?
	 Je stabilní.
	 Je přirozený.
	 Nevyžaduje další paměť.
	 Není efektivní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579083839991
Na které animaci je zobrazeno bublinkové řazení (bubble sort)?
	 {'image': 'eb5aac737b7fc58b65ca3b715737703e3954b7b290dc461d318820a712dec957', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579084078605
<uu5string/>Časová složitost algoritmu bubble sort je $1.
	 <uu5string/><UU5.Math.Expression expression="O(n^2)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084321088
V čem spočívá základní myšlenka algoritmu bubble sort?
	 Každé dva sousední prvky se prohodí, nejsou-li ve správném pořadí.
------------------------------------------------------------------------------------------------------------------------------
QC_1579084581636
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole čísel [5, 3, 6, 4]
	 [3, 5, 6, 4]
	 [3, 5, 4, 6]
	 [3, 4, 5, 6]
------------------------------------------------------------------------------------------------------------------------------
QC_1579084702512
<uu5string/>Který z kódů je kódem algoritmu bubble sort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bubbleSortAscending(array) {  for (let i = 0; i < array.length - 1; i++) {    for (let j = 0; j < array.length - i - 1; j++) {      if(array[j] > array[j+1]) {        let item = array[j];        array[j] = array[j+1];        array[j+1] = item;      }    }  }}     </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579084936785
<uu5string/>Jak bude vypadat průběh řazení algoritmem bubble sort pro pole písmen [c, a, e, b, d]
	 [a, c, e, b, d]
	 [a, c, b, e, d]
	 [a, c, b, d, e]
	 [a, b, c, d, e]
------------------------------------------------------------------------------------------------------------------------------
QC_1579085895829
<uu5string/>Pomocí kterého algoritmu je zde zobrazeno řazení polí?<br/>

[<UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>1</UU5.Bricks.Strong>, 4, 2, 8]<br/>

[1, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, 2, 8]<br/>

[1, 4, <UU5.Bricks.Strong>5</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 8]<br/>

[1, <UU5.Bricks.Strong>4</UU5.Bricks.Strong>, <UU5.Bricks.Strong>2</UU5.Bricks.Strong>, 5, 8]<br/>

[1, 2, 4, 5, 8]
	 bubble sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0025; Status: [200], uuAppErrorMap: {}
QC_1579088855642
<uu5string/>Jaké platí vlastnosti pro algoritmus merge sort?
	 Je stabilní.
	 Je přirozený.
	 Vyžaduje další paměť.
------------------------------------------------------------------------------------------------------------------------------
QC_1579089499266
<uu5string/>Merge sort je algoritmus založený na $1.
	 principu rozděl a panuj
------------------------------------------------------------------------------------------------------------------------------
QC_1579089722777
<uu5string/>Jaká je časová složitost algoritmu merge sort?
	 <uu5string/><UU5.Math.Expression expression="O (n \space log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1579090840039
Při implementaci merge sortu $1 použit rekurzi.
	 je vhodné
------------------------------------------------------------------------------------------------------------------------------
QC_1579091774312
Který z kódů je kódem algoritmu merge sort?
	 <uu5string/>    <UU5.CodeKit.CodeViewer codeStyle="javascript">  function mergeSort (array) {    if (array.length <= 1) {      return array;    }    let middle = Math.floor(array.length / 2);    let left = array.slice(0, middle);    let right = array.slice(middle);    return this.merge(this.mergeSort(left), this.mergeSort(right));  }  function merge (left, right) {    let resultArray = [];    let leftIndex = 0;    let rightIndex = 0;    while (leftIndex < left.length && rightIndex < right.length) {      if (left[leftIndex] < right[rightIndex]) {        resultArray.push(left[leftIndex]);        leftIndex++;      } else {        resultArray.push(right[rightIndex]);  			rightIndex++;      }    }    return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));  }    </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579093122970
<uu5string/>Vylepšením merge sortu se lze dodatečné paměti zbavit.
	 False
------------------------------------------------------------------------------------------------------------------------------
QC_1579094177631
Na kterém obrázku je pole setříděno merge sortem správně?
	 {'image': '79793df1062c893903efa4b230c5e1ee0732746a8fef4e520d96a3dc8885c5c0', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0026; Status: [200], uuAppErrorMap: {}
QC_1579159049430
<uu5string/>Jaké platí vlastnosti pro algoritmus quicksort?
	 <uu5string/>Je velmi rychlý vzhledem ke všem řadicím algoritmům.
	 Je přirozený.
	 <uu5string/>Časová složitost je <UU5.Math.Expression expression="O(n \space log \space n)"/>, v nejhorším případě <UU5.Math.Expression expression="O(n^2)"/>.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160004193
Který prvek se nazýva pivotem?
	 Jeden z prvků řazené posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579160430015
Za ideálně zvoleného pivota se považuje $1 řazené posloupnosti.
	 medián
------------------------------------------------------------------------------------------------------------------------------
QC_1579161352035
Který z kódů je kódem algoritmu quicksort?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">quickSort(array, left, right) {    if (left < right) {       let boundary = left;      for(let i = left + 1; i < right; i++) {         if(array[i] < array[left]) {          boundary = boundary + 1;          this.swap(array, i, boundary);        }      }      this.swap(array, left, boundary);      this.quickSort(array, left, boundary);      this.quickSort(array, boundary + 1, right);    }     }        </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1579163397539
<uu5string/>K čemu při implementaci quicksortu dojde, bude-li opakovaně nejmenší prvek volen jako pivot (za předpokladu velké posloupnosti)?
	 K pádu aplikace z důvodu vyčerpání paměti.
	 <uu5string/>K lineárnímu růstu spotřeby paměti.
------------------------------------------------------------------------------------------------------------------------------
QC_1579165230130
<uu5string/>Máme neseřazené pole [86, 84, 37, 56, 79, 90, 31, 86, 43]. Který prvek bude pivotem, pokud budeme volit metodou mediánu?
	 79
------------------------------------------------------------------------------------------------------------------------------
QC_1579165783770
<uu5string/>Který algoritmus má vždy časovou složitost <UU5.Math.Expression expression="O(n \space log \space n)"/>?
	 merge sort
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0027; Status: [200], uuAppErrorMap: {}
QC_1579172399882
<uu5string/>Jaké platí vlastnosti pro algoritmus heapsort?
	 Má konstantní paměťovou náročnost.
	 Není přirozený.
	 Není stabilní.
------------------------------------------------------------------------------------------------------------------------------
QC_1579174635592
<uu5string/>Základem řadicího algoritmu heapsort je datová struktura $1.
	 halda
------------------------------------------------------------------------------------------------------------------------------
QC_1579244067131
Jak bude vypadat pole čísel [4, 3, 7, 1, 8, 5] seřazené heapsortem (řadíme od největšího prvku po nejmenší). 
	 {'image': '141fb91b51e6478ab43580e139f3f0781acf3becabaf1a4fe9892acf64b9aeb8', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579245391882
<uu5string/>Jak bude vypadat pole čísel [26, 22, 25, 8, 13, 7, 11, 20] seřazené heapsortem (řadíme od nejmenšího prvku po největší). 
	 {'image': '4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579246312611
Které z následujících vlastností platí pro haldu?
	 Poslední "patro" haldy je zaplněno zleva.
	 Strom je velmi vyvážený.
	 Každý vnitřní vrchol má právě 2 syny.
------------------------------------------------------------------------------------------------------------------------------
QC_1579246845037
<uu5string/>Jak bude vypadat následující halda po smazaní kořenového prvku?
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=4e728602ccccde3804777ba73e389db0de330bca297cfa2ad863cfbadb15a5d9"
	style="maxHeight: 200px"
/>

	 {'image': '87955d5ac5092dc24598c9b1b7bde32ccb3e76997b061caa81608a6a6f95e077', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1579249200759
Jak vypadá průběh algoritmu heapsort?
	 Postavíme max nebo min heap.
	 Utrhneme vrchol haldy a prohodíme utržený prvek s posledním prvkem haldy.
	 <uu5string/>Zmenšíme haldu o 1.
	 <uu5string/>Vrátíme se do kroku číslo 2, pokud jsou v haldě prvky.
	 Pole je seřazené v opačném pořadí, než je priorita prvků.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0028; Status: [200], uuAppErrorMap: {}
QC_1580131079991
Ve kterých datových strukturách se používají následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131288149
Časová složitost binárního vyhledávání je $1.
	 <uu5string/><UU5.Math.Expression expression="O(log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580131525215
<uu5string/>Na jakých principech fungují následující typy vyhledávaní?
------------------------------------------------------------------------------------------------------------------------------
QC_1580131755336
Který z uvedených algoritmů stojí na myšlence rozděl a panuj?
	 Binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132036023
Pro hledání jména v telefonním seznamu je vhodnější použít $1.
	 binární vyhledávání
------------------------------------------------------------------------------------------------------------------------------
QC_1580132955724
<uu5string/>Seřaďte jednotlivé kroky algoritmu binárního vyhledávání?
	 Zvolíme medián seřazené posloupnosti (n/2).
	 Pokud se hledaný prvek shoduje s mediánem, ukončit hledání.
	 <uu5string/>Pokud je medián větší, tak pokračovat do pravé poloviny posloupnosti, pokud je menší, tak do levé.
	 <uu5string/>Pokračovat v půlení posloupnosti až do nalezení hledaného prvku, anebo do vyčerpání posloupnosti.
------------------------------------------------------------------------------------------------------------------------------
QC_1580299691682
Přiřaď časovou složitost algoritmu.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0029; Status: [200], uuAppErrorMap: {}
QC_1580201828181
Které vlastnosti platí pro binární vyhledávací strom?
	 <uu5string/>Binární strom má v každém uzlu <UU5.Bricks.U>nejvýše</UU5.Bricks.U> dva potomky.
	 Každý uzel má přiřazený klíč.
	 <uu5string/>Strom může, ale také nemusí umožňovat duplicity.
------------------------------------------------------------------------------------------------------------------------------
QC_1580201957493
<uu5string/> Pokud strom <UU5.Bricks.U>neumožňuje</UU5.Bricks.U> duplicity, hovoříme o $1.
	 stromu s unikátními hodnotami
------------------------------------------------------------------------------------------------------------------------------
QC_1580202715731
Co je typické pro následující typy stromů?
------------------------------------------------------------------------------------------------------------------------------
QC_1580204747690
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do binárního vyhledávacího stromu [12, 15, 3, 35, 21, 42, 14], jak poté bude takový strom vypadat?
	 {'image': '3a32dfd937c87ae643c15f1520ecb3878df1b5019c3553439c8cf58d7de06667', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580205186782
<uu5string/>Pokud budeme vkládat prvky v následujícím pořadí do AVL stromu [12, 15, 3, 35, 21, 42, 14], jak bude poté takový strom vypadat?
	 {'image': '1bec113b622f17db29566ebf61385142c0deee592adeed154a375f7b5a308d28', 'desc': None}
------------------------------------------------------------------------------------------------------------------------------
QC_1580210621167
$1 je strom využívající některých vlastností haldy.
	 Tree heap
------------------------------------------------------------------------------------------------------------------------------
QC_1580299921052
Průměrná časová složitost operace vyhledávání v binárním vyhledávacím stromu je $1.
	 <uu5string/><UU5.Math.Expression expression="O (log \space n)"/>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0030; Status: [200], uuAppErrorMap: {}
QC_1580216968743
<uu5string/>Ve kterých případech se dá použit hashovací funkce?
	 V kryptografii.
	 Pro skladování hesel.
	 Při kontrole integrity dat.
------------------------------------------------------------------------------------------------------------------------------
QC_1580217678350
$1 je funkce, která převádí vstupní libovolnou posloupnost bitů na posloupnost bitů pevné délky.
	 Hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580218722163
Kolize je situace, kdy se záznamy s různými klíči hashují zvolenou funkcí na stejné místo v hashovací tabulce.
	 True
------------------------------------------------------------------------------------------------------------------------------
QC_1580219157713
Co z následujícího patří mezi vlastnosti hashovací funkce?
	 Malou změnou vstupních dat dosáhneme velké změny na výstupu.
	 Jakékoliv množství vstupních dat poskytuje stejně dlouhý výstup.
	 Z hashe je prakticky nemožné rekonstruovat původní text zprávy.
------------------------------------------------------------------------------------------------------------------------------
QC_1580294531631
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [126, 145, 276, 548, 466] a hashovácí funkce <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
 Které hodnoty budou zařazeny do hashovací tabulky pod stejným hashem?
</UU5.Bricks.P>
	 126, 276, 466
------------------------------------------------------------------------------------------------------------------------------
QC_1580297750497
<uu5string/><UU5.Bricks.P>
 <UU5.Bricks.Em>
   Máme následující vstupní hodnoty [121, 145, 273, 542, 464, 275] a hashovácí funkci <UU5.Math.Expression expression="x \space mod \space 10"/>.
</UU5.Bricks.Em>
</UU5.Bricks.P>
<UU5.Bricks.P>
  <UU5.Bricks.Em>Nápověda: kolize se řeší tak, že se prvek vloží na následující nejbližší volný hash.</UU5.Bricks.Em>
 Jak bude ve výsledku vypadat hashovací tabulka?<br/>
</UU5.Bricks.P>
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='1' />      <UU5.Bricks.Table.Td content='121' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='2' />      <UU5.Bricks.Table.Td content='542' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='3' />      <UU5.Bricks.Table.Td content='273' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='4' />      <UU5.Bricks.Table.Td content='464' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='5' />      <UU5.Bricks.Table.Td content='145' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='6' />      <UU5.Bricks.Table.Td content='275' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0031; Status: [200], uuAppErrorMap: {}
QC_1580382075914
Na čem závisí časová složitost algoritmu vyhledávání hrubou silou?
	 Na délce textu.
	 Na délce hledaného řetězce (pattern).
------------------------------------------------------------------------------------------------------------------------------
QC_1580382398263
<uu5string/>Jaký je postup fungování algoritmu vyhledávání hrubou silou?
	 Porovná se první kandidát v textu s prvním symbolem v patternu.
	 Porovná se následující prvek s následujícím symbolem v patternu, pokud takový je.
	 Pokud se prvky nerovnají v patternu, index se nastaví na 0, v textu současný index + 1 a pokračuje od kroku 1.
	 <uu5string/>Pokud se všechny symboly v patternu a všechny symboly v textu shodují, tak ukonči běh.
------------------------------------------------------------------------------------------------------------------------------
QC_1580383429939
Co z následujícího platí pro algoritmus vyhledávání hrubou silou?
	 Hledá zadaný vzor v daném textu tak, že prochází zepředu text a také vzor a porovnává, zdali jsou totožné.
------------------------------------------------------------------------------------------------------------------------------
QC_1580386108483
Který z pseudokódů je pseudokód algoritmu vyhledávání hrubou silou?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function bruteForceStringMatch(pattern, text) {    var M = pattern.length;    var N = text.length;    for (var i = 0; i <= N - M; ++i) {        var matched = true;        for (var j = 0; j < M; ++j) {            if (text.charAt(i + j) != pattern.charAt(j)) {                matched = false;                break;            }        }        if (matched) {            return i;        }    }    return -1;}</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390101269
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejhorší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = ccccca;text = ccccccccccccccccccccccccccca;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
QC_1580390541091
<uu5string/>Pro který vstup (pattern a text) bude časová složitost algoritmu vyhledávání hrubou silou <UU5.Bricks.U>nejlepší</UU5.Bricks.U>?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">pattern = acc;text = accccc;</UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0032; Status: [200], uuAppErrorMap: {}
QC_1580392699473
<uu5string/>Ze kterých dílčích časových složitostí se skladá celková časová složitost Knuth-Morris-Pratt algoritmu?
	 Čas samotného vyhledávání.
	 Čas potřebný na vytvoření pomocné tabulky.
------------------------------------------------------------------------------------------------------------------------------
QC_1580460634417
<uu5string/>Jaké vlastnosti jsou platné pro Knuth-Morris-Pratt algoritmus?
	 <uu5string/>Při neúspěšném porovnání se nevrací zpět v textu.
	 Používá pomocnou tabulku pro porovnání.
------------------------------------------------------------------------------------------------------------------------------
QC_1580465589060
<uu5string/>K čemu slouží čísla, která uchovává pomocná tabulka Knuth-Morris-Pratt algoritmu?
	 Abychom věděli, kolikátý prvek vzoru máme porovnávat s aktuálním znakem textu.
------------------------------------------------------------------------------------------------------------------------------
QC_1580470238643
Jak bude vypadat pomocná tabulka vytvořená k patternu [A,B,C,D,A,B,D]?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='C' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='A' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='B' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='D' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580471077578
<uu5string/>Jak bude vypadat pomocné pole vytvořené k patternu [A,B,A,C,A,B,A]?
	 <uu5string/>[0,0,1,0,1,2,3]
------------------------------------------------------------------------------------------------------------------------------
QC_1580471707083
<uu5string/>Jaký je postup tvorby pomocné tabulky Knuth-Morris-Pratt algoritmu?
	 Definujeme jednorozměrné pole (table[pattern.length])
	 <uu5string/>Definujte proměnné i = 0 a j = 1, table[0] = 0.
	 Porovnáme hodnoty pattern [i] a pattern [j].
	 <uu5string/>Pokud se hodnoty shodují, nastavíme table [j] = i + 1 a obě hodnoty i a j zvýšíme o jedna. Vrátíme se do předchozího krok.
	 <uu5string/>Pokud se hodnoty neshodují, zkontrolujeme hodnotu proměnné i. Pokud je 0, pak nastavíme table [j] = 0 a zvýšíme hodnotu j o jedna, pokud to není 0, pak nastavíme i = table [i-1]. Přejdeme do kroku 3.
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0033; Status: [200], uuAppErrorMap: {}
QC_1580726701328
Hlavní myšlenka Boyer-Moore algoritmu je možnost porovnávat znaky vzoru a znaky textu $1.
	  zprava
------------------------------------------------------------------------------------------------------------------------------
QC_1580727193238
<uu5string/>Jaká je průměrná asymptotická časová složitost Boyer-Moore algoritmu?
	 <uu5string/> <UU5.Math.Expression expression="O (n)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580728630851
<uu5string/>O kolik pozic posuneme pattern doprava, pokud se poslední porovnávaný prvek v textu nevyskytuje v pomocné tabulce Boyer-Moore algoritmu?
	 o délku patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580729535383
<uu5string/>Jak bude vypadat pomocná tabulka k patternu "abcd" podle Boyer-Moore algoritmu?
	 <uu5string/><UU5.Bricks.Table bordered>  <UU5.Bricks.Table.TBody>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='a' />      <UU5.Bricks.Table.Td content='3' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='b' />      <UU5.Bricks.Table.Td content='2' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='c' />      <UU5.Bricks.Table.Td content='1' />    </UU5.Bricks.Table.Tr>    <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='d' />      <UU5.Bricks.Table.Td content='0' />    </UU5.Bricks.Table.Tr>        <UU5.Bricks.Table.Tr>      <UU5.Bricks.Table.Td content='*' />      <UU5.Bricks.Table.Td content='4' />    </UU5.Bricks.Table.Tr>  </UU5.Bricks.Table.TBody></UU5.Bricks.Table>
------------------------------------------------------------------------------------------------------------------------------
QC_1580730105703
<uu5string/>Hodnotu, která nám ukáže, o kolik symbolů je potřeba se posunout v hledaném textu, vypočítáme pomocí vzorce $1 - $2 - 1.
	 délka patternu
	 index aktuálního prvku v patternu
------------------------------------------------------------------------------------------------------------------------------
QC_1580809202175
<uu5string/><UU5.Bricks.P>
 O kolik pozic po porovnání symbolu <UU5.Bricks.Em>a</UU5.Bricks.Em> a symbolu <UU5.Bricks.Em>d</UU5.Bricks.Em>
</UU5.Bricks.P>
<Plus4U5.Bricks.Image
	src="https://uuos9.plus4u.net/uu-coursekitg01-course/286a85d928da49ebb60816c715ae15dc/uu-app-binarystore/getBinaryData?code=af387154b8d99cd366d654a48722d9014143bbca7540e62de3ce517b50b67944"
	style="maxHeight: 200px"
/>

<UU5.Bricks.P>
v textu "eovadabcdf" se posune vyhledávaný řetězec (pattern) "abcd"?
</UU5.Bricks.P>
<UU5.Bricks.P>
 <UU5.Bricks.Em>Pomocná tabulka vypadá následovně:</UU5.Bricks.Em> 
</UU5.Bricks.P>
<UU5.Bricks.Table bordered>
  <UU5.Bricks.Table.TBody>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='a' />
      <UU5.Bricks.Table.Td content='3' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='b' />
      <UU5.Bricks.Table.Td content='2' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='c' />
      <UU5.Bricks.Table.Td content='1' />
    </UU5.Bricks.Table.Tr>
    <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='d' />
      <UU5.Bricks.Table.Td content='0' />
    </UU5.Bricks.Table.Tr>
        <UU5.Bricks.Table.Tr>
      <UU5.Bricks.Table.Td content='*' />
      <UU5.Bricks.Table.Td content='4' />
    </UU5.Bricks.Table.Tr>
  </UU5.Bricks.Table.TBody>
</UU5.Bricks.Table>
	 3
------------------------------------------------------------------------------------------------------------------------------
Lesson ID: LC_0034; Status: [200], uuAppErrorMap: {}
QC_1580812850260
<uu5string/>Základní myšlenka Karp-Rabin algoritmu stojí na $1.
	 <uu5string/>použití hashovací funkce
------------------------------------------------------------------------------------------------------------------------------
QC_1580816106702
Kde všude v praxi se Karp-Rabin algoritmus používá?
	 Pro detekci počítačových virů.
	 V oblastech odhalování plagiátorství textů.
------------------------------------------------------------------------------------------------------------------------------
QC_1580825128568
Průměrná časová složitost Karp-Rabin algoritmu je O ($1 + $2 ⋅ $3)
	 m
	 n
	 c
------------------------------------------------------------------------------------------------------------------------------
QC_1580972702632
<uu5string/>Jaká je nejhorší časová složitost Karp-Rabin algoritmu?
	 <uu5string/><UU5.Math.Expression expression="O(m+n \cdot m)"/>
------------------------------------------------------------------------------------------------------------------------------
QC_1580973201140
<uu5string/>Hashovací funkce by měla mít $1 časovou složitost pro jakoukoliv délku hledaného vzoru a měla by $2 kolize.
	 konstantní
	 minimalizovat
------------------------------------------------------------------------------------------------------------------------------
QC_1580975247175
Jak vypadá kód Karp-Rabin algoritmu?
	 <uu5string/><UU5.CodeKit.CodeViewer codeStyle="javascript">function RabinKarp(text, pattern) {   if (pattern.length > text.length) {    return -1;  }    let patternHash;  let cutoutHash;  for (let i = 0; i < pattern.length; i++) {    patternHash = getNewHash(patternHash, pattern.charAt(i));    cutoutHash = getNewHash(cutoutHash, text.charAt(i));  }  let textIndex = 0;  while (textIndex < text.length) {    if (cutoutHash == patternHash) {      if (searchNaive(text, pattern, textIndex, textIndex + pattern.length)) {        return textIndex;      }    }    if (textIndex < (text.length - pattern.length)) {      addedCharacter = text.charAt(textIndex + pattern.length);      removedCharacter = text.charAt(textIndex);      cutoutHash = getNewHash(cutoutHash, addedCharacter, removedCharacter);      textIndex = textIndex + 1;    } else {      return -1;    }  }}  </UU5.CodeKit.CodeViewer>
------------------------------------------------------------------------------------------------------------------------------
➜  unifetch git:(master) ✗ 
